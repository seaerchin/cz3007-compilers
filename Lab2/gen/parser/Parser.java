package parser;

import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "parser.beaver".
 */
public class Parser extends beaver.Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short LBRACKET = 2;
		static public final short LPAREN = 3;
		static public final short MINUS = 4;
		static public final short STRING_LITERAL = 5;
		static public final short INT_LITERAL = 6;
		static public final short TRUE = 7;
		static public final short FALSE = 8;
		static public final short RPAREN = 9;
		static public final short SEMICOLON = 10;
		static public final short VOID = 11;
		static public final short BOOLEAN = 12;
		static public final short INT = 13;
		static public final short LCURLY = 14;
		static public final short RCURLY = 15;
		static public final short IF = 16;
		static public final short WHILE = 17;
		static public final short BREAK = 18;
		static public final short RETURN = 19;
		static public final short RBRACKET = 20;
		static public final short COMMA = 21;
		static public final short EQL = 22;
		static public final short IMPORT = 23;
		static public final short PUBLIC = 24;
		static public final short PLUS = 25;
		static public final short TIMES = 26;
		static public final short DIV = 27;
		static public final short MOD = 28;
		static public final short TYPE = 29;
		static public final short MODULE = 30;
		static public final short ELSE = 31;
		static public final short EQEQ = 32;
		static public final short NEQ = 33;
		static public final short LT = 34;
		static public final short LEQ = 35;
		static public final short GT = 36;
		static public final short GEQ = 37;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pDLWbKLLKKtUynsAU0L12e93D54O4G8KHa4CGq88CGBHDjq4fji57DiI9HIzD4rwhLg5c" +
		"P3JQdsMnpQTcWMQbfHZOvb5hQQR$xBv$du$$Fi7BL$sk$Syuz#vnttxdttVC0SndEGoRAK8" +
		"WpC015A4O5#c0yCj0BfJWPr#1QT45NH2C69#14d8JsY4KuEY02OSfhebsBSdHaZiuOWg4uL" +
		"#vjKewe1ZaQZ#dUWfYK5iHCQX1p7ORX8XJWJ0p41RWGPs4qRiHaJ44d#GNN8n4zqBC1Qpgh" +
		"KiVwsIVh5XlBTwu01DQnCDydgvNizx3Q#6IrnIaUrgaUbhUwdAxhuirNwV7rT$Xov20YSRx" +
		"U3zjKjMv7cjyi9Ouvnii7w8OuZ6pMlVDmirh1Ixn69VjvcYm$la5#VEL#V1VxyKtGlb0aO2" +
		"6IS1hcoW64u5WSXzim3sCGX6DOjU06bN7Qbw4tKf4kxoCNVJ4Mut0vhi2LkAhHIAUTxwYcq" +
		"z#l4V$HjaCnJQrk5LmusrEhAWp6ENe$Ls6Cx64Lt5OkMiikhH#F6PY9gSZ6S5oDM#Lhrcq4" +
		"Hk5It829iXitoO#encpCmXo#NtTW0UxaxhDEkdZkmmIUFObSfMIkKmhVbbI#Bsb8r#z79bS" +
		"WYskQZHmOF4FxQcyiwzNo7ExJfwA5EVxFCTRpMUTP47TtA#vooxBMCfHTA9mhrPfdLzi6BC" +
		"l#zrXX7bQKJrOuu66vVBB2s3thM24Ubh#wDDSNpd#ktW$kkqTpp$lBufnZ6MTMhh8qxzxk5" +
		"Mnkr7$dosC7xySdT$6K2bVdr42U7YMin21seMYU6jxsYzsEuTTBYFhdy#Jfm4xPaJso4xzk" +
		"6ejqsivvDjT$jEqylRe6QnNXgPL1lUuDCiXsiGfkAvzdlalh0UnSxNdg5fDjrIgITOkarwL" +
		"gxrAwmJjPjOpYYXYKGCqqg9z9$4Hi8JO3HXhbRag3M6Tnx21zF2ynbBE82TGFanT4kPmoNU" +
		"TSuunhc8Sd42VYrermFRQU#j1wZh7Anj#knpOIjSG66llrs1ujXn5xjRxFbcS7iLlhMpdlO" +
		"68o4SQ1pfJjzBF5DJPlFPULvAOJ8srrcKXa4wFrVHAzrAwGcABr6KI9mp#OcAlruSIyfit7" +
		"h3xIDWPmR14nYfXFEyHBp09UrbBID6SIKscpjkP26#SUOZPn5x7OIuuvMYuXxhRxH6INRJu" +
		"rn69RN98p5$crDd#MRNnJ$JXYcr8FBxaFEUhJnfOpmpPUgSTAZ#JZWA$SZ1cdvrn0FO9OJP" +
		"HgUL3xN4sTAsCcUHchhjVD72$#O8STxx0NsVI2fix5pnoNkYN6De5RtFpyPgNtSTH0$#Imx" +
		"5Hof$mflyi#sGl7JtYcoQ#oMRwIJR9HlfGlv7Cr$WtncT8so6$ogQoNJwX$x8dxYFXGQUyH" +
		"xyZRie9ohRp6wol42yGpn1FokAoGnsIvF2gFoCEoJDvIKM$8g$AcqbwNvsMbF2LFojFAVa3" +
		"kv$K#UKYMAdk9kZuepycpiaPUbjMoIbwI5pdshcoNxzpv56UTR9KjygtZ2RT9hKV$GNR8z$" +
		"AN79A$bVs72CK8Tbk3CDbnGHZiknPCzbwe$bl1$cFrw4BLUTmeeg#8ih#2zVKBmc1NSh7Bc" +
		"4GWkrCWUrGmUnHKdyeZUjgGPaEwwb0clpqDd#X5JYPHndnbj7kJdy6ULKwPHTc7agSZOV2h" +
		"DO3VhIQ$Cmo55DfTA2rqvRmizA1k8PM#OaflIAOlcJ9V8ubs4cM13N6yJnnbl1zqrqXaV3V" +
		"UEu4obtOkvP1$06tAZoW=");

	static final Action RETURN6 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 6];
		}
	};

	static final Action RETURN3 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 3];
		}
	};

	static final Action RETURN9 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 9];
		}
	};

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

	static final Action RETURN4 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 4];
		}
	};

	static final Action RETURN5 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 5];
		}
	};

	// turn off automated error recovery
	@Override
	protected void recoverFromError(Symbol token, TokenStream in) throws java.io.IOException, Exception {
		super.recoverFromError(new Symbol(0), in);
	}

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] lst$Import = Import
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [1] lst$Import = lst$Import Import
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [2] opt$lst$Import = 
			Action.RETURN,	// [3] opt$lst$Import = lst$Import
			new Action() {	// [4] lst$Declaration = Declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [5] lst$Declaration = lst$Declaration Declaration
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [6] opt$lst$Declaration = 
			Action.RETURN,	// [7] opt$lst$Declaration = lst$Declaration
			RETURN6,	// [8] Module = MODULE ID LCURLY opt$lst$Import opt$lst$Declaration RCURLY; returns 'RCURLY' although none is marked
			RETURN3,	// [9] Import = IMPORT ID SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.RETURN,	// [10] Declaration = FuncDec
			Action.RETURN,	// [11] Declaration = TypeDec
			Action.RETURN,	// [12] Declaration = FieldDec
			Action.NONE,  	// [13] opt$ParamList = 
			Action.RETURN,	// [14] opt$ParamList = ParamList
			new Action() {	// [15] lst$Statement = Statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			new Action() {	// [16] lst$Statement = lst$Statement Statement
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2]); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [17] opt$lst$Statement = 
			Action.RETURN,	// [18] opt$lst$Statement = lst$Statement
			RETURN9,	// [19] FuncDec = AccSpec Type ID LPAREN opt$ParamList RPAREN LCURLY opt$lst$Statement RCURLY; returns 'RCURLY' although none is marked
			RETURN2,	// [20] ParamList = Type ID; returns 'ID' although none is marked
			RETURN4,	// [21] ParamList = Param COMMA Type ID; returns 'ID' although none is marked
			RETURN4,	// [22] FieldDec = AccSpec Type ID SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN6,	// [23] TypeDec = AccSpec TYPE ID EQL STRING_LITERAL SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.NONE,  	// [24] opt$PUBLIC = 
			Action.RETURN,	// [25] opt$PUBLIC = PUBLIC
			Action.RETURN,	// [26] AccSpec = opt$PUBLIC
			Action.RETURN,	// [27] Type = Primitive
			Action.RETURN,	// [28] Type = Array
			Action.RETURN,	// [29] Type = ID
			Action.RETURN,	// [30] Primitive = VOID
			Action.RETURN,	// [31] Primitive = BOOLEAN
			Action.RETURN,	// [32] Primitive = INT
			RETURN3,	// [33] Array = Type LBRACKET RBRACKET; returns 'RBRACKET' although none is marked
			RETURN2,	// [34] Param = Type ID; returns 'ID' although none is marked
			Action.RETURN,	// [35] Statement = LocalVar
			Action.RETURN,	// [36] Statement = Block
			Action.RETURN,	// [37] Statement = IfElse
			Action.RETURN,	// [38] Statement = While
			Action.RETURN,	// [39] Statement = Break
			Action.RETURN,	// [40] Statement = Return
			Action.RETURN,	// [41] Statement = ExprStatement
			RETURN3,	// [42] LocalVar = Type ID SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN3,	// [43] Block = LCURLY opt$lst$Statement RCURLY; returns 'RCURLY' although none is marked
			Action.NONE,  	// [44] opt$Else = 
			Action.RETURN,	// [45] opt$Else = Else
			RETURN2,	// [46] IfElse = If opt$Else; returns 'opt$Else' although none is marked
			RETURN5,	// [47] If = IF LPAREN Expr RPAREN Statement; returns 'Statement' although none is marked
			RETURN2,	// [48] Else = ELSE Statement; returns 'Statement' although none is marked
			RETURN5,	// [49] While = WHILE LPAREN Expr RPAREN Statement; returns 'Statement' although none is marked
			RETURN2,	// [50] Break = BREAK SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.NONE,  	// [51] opt$Expr = 
			Action.RETURN,	// [52] opt$Expr = Expr
			RETURN3,	// [53] Return = RETURN opt$Expr SEMICOLON; returns 'SEMICOLON' although none is marked
			RETURN2,	// [54] ExprStatement = Expr SEMICOLON; returns 'SEMICOLON' although none is marked
			Action.RETURN,	// [55] Expr = Assignment
			Action.RETURN,	// [56] Expr = RightHandExpr
			RETURN3,	// [57] Assignment = LeftHandExpr EQL Expr; returns 'Expr' although none is marked
			Action.RETURN,	// [58] LeftHandExpr = ID
			Action.RETURN,	// [59] LeftHandExpr = ArrayAccess
			RETURN4,	// [60] ArrayAccess = ID LBRACKET Expr RBRACKET; returns 'RBRACKET' although none is marked
			RETURN4,	// [61] ArrayAccess = ArrayAccess LBRACKET Expr RBRACKET; returns 'RBRACKET' although none is marked
			Action.RETURN,	// [62] RightHandExpr = ArithExpr
			Action.RETURN,	// [63] RightHandExpr = ComplexArith
			RETURN3,	// [64] ComplexArith = ArithExpr CompOp ArithExpr; returns 'ArithExpr' although none is marked
			Action.RETURN,	// [65] CompOp = EQEQ
			Action.RETURN,	// [66] CompOp = NEQ
			Action.RETURN,	// [67] CompOp = LT
			Action.RETURN,	// [68] CompOp = LEQ
			Action.RETURN,	// [69] CompOp = GT
			Action.RETURN,	// [70] CompOp = GEQ
			new Action() {	// [71] ArithExpr = ArithExpr AddOp Term
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [72] ArithExpr = Term
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [73] AddOp = PLUS
			Action.RETURN,	// [74] AddOp = MINUS
			new Action() {	// [75] Term = Term MulOp Factor
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3]); return _symbols[offset + 1];
				}
			},
			new Action() {	// [76] Term = Factor
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1]); return new Symbol(lst);
				}
			},
			Action.RETURN,	// [77] MulOp = TIMES
			Action.RETURN,	// [78] MulOp = DIV
			Action.RETURN,	// [79] MulOp = MOD
			RETURN2,	// [80] Factor = MINUS Factor; returns 'Factor' although none is marked
			Action.RETURN,	// [81] Factor = Primary
			Action.RETURN,	// [82] Primary = LeftHandExpr
			Action.RETURN,	// [83] Primary = FuncCall
			Action.RETURN,	// [84] Primary = ArrayExpr
			Action.RETURN,	// [85] Primary = INT_LITERAL
			Action.RETURN,	// [86] Primary = STRING_LITERAL
			Action.RETURN,	// [87] Primary = Bool
			Action.RETURN,	// [88] Primary = ParenExpr
			Action.RETURN,	// [89] Bool = TRUE
			Action.RETURN,	// [90] Bool = FALSE
			RETURN3,	// [91] ParenExpr = LPAREN Expr RPAREN; returns 'RPAREN' although none is marked
			RETURN4,	// [92] FuncCall = ID LPAREN ExprList RPAREN; returns 'RPAREN' although none is marked
			RETURN3,	// [93] ArrayExpr = LBRACKET ExprList RBRACKET; returns 'RBRACKET' although none is marked
			Action.RETURN,	// [94] ExprList = Expr
			RETURN3	// [95] ExprList = Expr COMMA ExprList; returns 'ExprList' although none is marked
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
