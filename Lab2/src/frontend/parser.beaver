// package the generated Java class lives in; no need to change this
%package "parser";

// name of the generated Java class; no need to change this
%class "Parser";

// no need to change this either
%embed {:
	// turn off automated error recovery
	@Override
	protected void recoverFromError(Symbol token, TokenStream in) throws java.io.IOException, Exception {
		super.recoverFromError(new Symbol(0), in);
	}
:};

// the list of all terminals; no need to change this
%terminals MODULE, INT, VOID, IF, ELSE, WHILE, RETURN, BREAK, BOOLEAN, PUBLIC, TRUE, FALSE,
           INT_LITERAL, STRING_LITERAL, ID, TYPE, IMPORT,
           PLUS, MINUS, TIMES, DIV, MOD, EQEQ, NEQ, LEQ, GEQ, LT, GT,
           LBRACKET, RPAREN, COMMA, RCURLY, LCURLY, SEMICOLON, RBRACKET, LPAREN, EQL;

// Operator Precedence
%left MODULE;
%left INT;
%left VOID;
%left IF;
%left ELSE;
%left WHILE;
%left RETURN;
%left BREAK;
%left BOOLEAN;
%left PUBLIC;
%left TRUE;
%left FALSE;
%left INT_LITERAL;
%left STRING_LITERAL;
%left ID;
%left TYPE;
%left IMPORT;
%left PLUS;
%left MINUS;
%left TIMES;
%left DIV;
%left MOD;
%left EQEQ;
%left NEQ;
%left LEQ;
%left GEQ;
%left LT;
%left GT;
%left LBRACKET;
%left RPAREN;
%left COMMA;
%left RCURLY;
%left LCURLY;
%left SEMICOLON;
%left RBRACKET;
%left LPAREN;
%left EQL;

// declaration of start symbol; no need to change this
%goal Module;

/* ------- Our code begins here. ------- */
// NOTE: Beaver uses EBNF to specify rules.
// These EBNF rules are then used to generate a  java class that implements the parser.
// Hence, Beaver is a parser generator.
// Read more: http://beaver.sourceforge.net/ (tbh, looks ancient)
// Syntax page: http://beaver.sourceforge.net/spec.html
// NOTE: Beaver finds the rightmost terminal symbol that has precedence and uses this to assign precedence to rules if
// the precedence is not explicitly defined for a rule.
// If none can be found, the rule will be set to the lowest precedence.
/* TODO: Flesh out the rule for Module, and add rules for other nonterminals. Here is an example
         of a rule you may want to add:
         
   Accessibility = PUBLIC
		  |
		  ;
  */

/*
EBNF Notation:
1. SCREAMING_SNAKE_CASE: Base tokens (string literals included)
2. PascalCase: production rules
*/

// A module is a keyword module followed by ident, then open brace, some imports, declarations then close brace
// The imports/declarations can be empty
// We define them here to avoid ambiguity later on
// through forms such as Import = "" | concreteImport
// in EBNF: Module = IDENT "{" imports, dec "}"
Module = MODULE LCURLY Import Declaration RCURLY;

// An import statement consists of 0 or more import statements.
// As explained above, we omit the optional declaration here in favour of expressing it in Module.
// In EBNF: Import = "import" IDENT ";"
Import = IMPORT ID SEMICOLON;

// A declaration is function or type or field declaration
Declaration = FuncDec | TypeDec | FieldDec;

// A function declaration consists of a few things but it'll be omitted here for brevity
// in EBNF: FuncDec = Accessibility Type IDENT "(" ParamList ")" "{" Statements? "}"
FuncDec = AccSpec Type ID LPAREN Param* RPAREN LCURLY Statement* RCURLY;

FieldDec = AccSpec Type ID SEMICOLON;

// A type declaration consists of accessibility specifier, typename, identifier and semicolon
// in EBNF: TypeDec = Accessibility Type IDENT "=" IDENT ";"
TypeDec = AccSpec TYPE ID EQL STRING_LITERAL SEMICOLON; // TYPE is the terminal

AccSpec = PUBLIC?;

// A type name is either a primitive, an array of an identifier.
// NOTE: This might be wrong wrt the identifier portion
Type = Primitive | Array | ID;

// What is void... why make a language with void......
Primitive = VOID | BOOLEAN | INT;

// An array is a typename, left bracket then right bracket
Array = Type LBRACKET RBRACKET;

Param = Type ID;

Statement = LocalVar | Block | IfElse | While | Break | Return | ExprStatement;

LocalVar = Type ID SEMICOLON;

Block = LCURLY Statement* RCURLY;

// IfThenElse is da wae..........................................
// The semantics of this language means that a statement if (False) { /.../ } will always return void wtf...
IfElse = If Else?;

If = IF LPAREN Expr RPAREN Statement;

Else = ELSE Statement;

While = WHILE LPAREN Expr RPAREN Statement;

Break = BREAK SEMICOLON;

Return = RETURN Expr? SEMICOLON;

// NOTE: Better naming could be helpful here
// Broken into 2 to allow the Or grouping to occur separately for readability
ExprStatement = Expr SEMICOLON;

Expr = Assignment | RightHandExpr;

Assignment = LeftHandExpr EQL Expr;

LeftHandExpr = ID | ArrayAccess;

ArrayAccess = LeftHandExpr LBRACKET Expr RBRACKET;

RightHandExpr = ArithExpr | ComplexArith;

ComplexArith = ArithExpr CompOp ArithExpr;

CompOp = EQEQ | NEQ | LT | LEQ | GT | GEQ;

ArithExpr = ArithExpr AddOp Term | Term;

AddOp = PLUS | MINUS;

Term = Term MulOp Factor | Factor;

MulOp = TIMES | DIV | MOD;

Factor = MINUS Factor | Primary;

Primary = LeftHandExpr | FuncCall | ArrayExpr | ID | INT_LITERAL | STRING_LITERAL | Bool | ParenExpr;

Bool = TRUE | FALSE;

ParenExpr = LPAREN Expr RPAREN;

FuncCall = ID LPAREN ExprList RPAREN;

/*
An expression list is basically: (expr, expr, expr) OR (expr).
This can never be empty.
Note that because of the comma, we have 2 building blocks.
The first is the basic (expr), which is the only one WITHOUT a comma.
For any other forms of the expression list, we need expr + COMMA (expr,)
This means that we express this as a list of 2 types of items.
*/
ArrayExpr = LBRACKET ExprList RBRACKET;

ExprList = ExprListItem+;

ExprListItem = Expr | ExprComma? Expr;

ExprComma = Expr COMMA;

/**/
